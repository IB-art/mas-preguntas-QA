<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>75 вопросов на собеседовании QA</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Kurale&family=Open+Sans:ital,wght@0,300;0,400;0,600;0,800;1,700&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/slick.css">
  <link rel="stylesheet" href="css/jquery.fancybox.css">
  <link rel="stylesheet" href="css/magnific-popup.css">
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <header class="header">
    <div class="container">

      <div class="product-one__content">

        <div class="top__top">
          <h2 class="product-one__title">Вопросы с собеседований на QA Engineer от Stepik #2</h2>
          <div class="paginacia">
            <a href="index.html">1</a>
            <a class="paginacia__link--active" href="/">2</a>
          </div>
        </div>

        <div class="product-one__tabs">
          <div class="tabs">
            <span class="tab active" data-id="31">31. Что такое Quality Assurance ( QA )</span>
            <span class="tab" data-id="65">65. Какие виды тестирования бы применил к веб приложению</span>
            <span class="tab" data-id="32">32. Расскажи про методологии разработки scrum</span>
            <span class="tab" data-id="45">45. Что происходит в конце спринта</span>
            <span class="tab" data-id="33">33. Что описывается в тест плане</span>
            <span class="tab" data-id="34">34. Что такое эквивалентное разделение</span>
            <span class="tab" data-id="35">35. Техника анализа граничных значений, можешь о ней рассказать</span>
            <span class="tab" data-id="36">36. Почему выбрал тестирование</span>
            <span class="tab" data-id="37">37. Что такое тестирование инсталляции</span>
            <span class="tab" data-id="38">38. Расскажи про нефункциональные виды тестирования</span>
            <span class="tab" data-id="39">39. Какие существуют типы баз данных</span>
            <span class="tab" data-id="60">60. Расскажи про API тестирование</span>
            <span class="tab" data-id="64">64. Какое тестирование применяется к тестированию api</span>
            <span class="tab" data-id="61">61. Чем API отличается для веб-клиента от мобильного</span>
            <span class="tab" data-id="40">40. Что можешь рассказать про SQL</span>
            <span class="tab" data-id="41">41. Расскажи про join'ы</span>
            <span class="tab" data-id="42">42. Что такое rest api</span>
            <span class="tab" data-id="44">44. Что такое Dev Tool</span>
            <span class="tab" data-id="48">48. Расскажи о критериях начала тестирования</span>
            <span class="tab" data-id="49">49. Что такое серый ящик в тестировании</span>
            <span class="tab" data-id="50">50. Какие знаешь статус коды</span>
            <span class="tab" data-id="51">51. Расскажи про кросс-браузерное тестирование</span>
            <span class="tab" data-id="66">66. Что такое http</span>
            <span class="tab" data-id="52">52. Из чего состоит запрос на сервере</span>
            <span class="tab" data-id="53">53. Из чего состоит ответ на сервере</span>
            <span class="tab" data-id="54">54. Какие http методы могут быть</span>
            <span class="tab" data-id="55">55. Что означает 405 ошибка</span>
            <span class="tab" data-id="56">56. Что такое 500 ошибка</span>
            <span class="tab" data-id="57">57. Для тестирования ПО где можно взять ожидаемый результат</span>
            <span class="tab" data-id="62">62. Что знаешь про клиент серверную архитектуру</span>
            <span class="tab" data-id="63">63. Какой придет статус код, если сервер сломан</span>
            <span class="tab" data-id="67">67. Какая разница у протоколов http и https</span>



            <!-- <p>__________________</p> -->
          </div>

          <div class="tab__content">

            <div class="tab-item active-tab" id="31">
              <div class="tab__box">
                <p><i>Quality Assurance (QA) </i>— это процесс, направленный на предотвращение дефектов в продуктах и
                  процессах разработки путем внедрения стандартов и процедур качества.</i>.
                </p>
                <p><i>Основная цель QA </i>— обеспечить, чтобы продукт соответствовал требованиям и ожиданиям
                  клиентов,
                  тем самым повышая доверие к продукту и снижая затраты на его доработку.</p>
                <p>__________________</p>
                <p><i>Quality Assurance (QA), или Обеспечение Качества, </i>— это систематический процесс,
                  направленный
                  на обеспечение того, чтобы продукт или услуга соответствовали определенным стандартам качества и
                  требованиям клиентов.</p>
                <p><i>Цель </i>— предотвратить дефекты в продуктах и процессах разработки еще на ранних этапах, до
                  того
                  как продукт попадет к конечному пользователю. <br>Это достигается за счет внедрения стандартных
                  процедур и методик на всех этапах разработки и производства.</p>
                <p><b>Основные аспекты:</b></p>
                <ul class="top">
                  <li><i>Планирование качества: </i>Определение стандартов качества, которых должен достичь продукт, и
                    разработка планов по их достижению.</li>
                  <li><i>Контроль качества (QC): </i>Практические действия и процедуры, направленные на обнаружение
                    дефектов в продукте или процессе. <br>QC часто путают с QA, но контроль качества фокусируется на
                    обнаружении и исправлении проблем, в то время как оно направлено на предотвращение их
                    возникновения.
                  </li>
                  <li><i>Управление качеством проекта: </i>Включает в себя планирование, организацию, мониторинг и
                    корректировку действий и процессов, чтобы обеспечить достижение требований к качеству.</li>
                  <li><i>Аудит и оценка качества: </i>Регулярные проверки и оценки процессов и продуктов на
                    соответствие
                    установленным стандартам и требованиям.</li>
                </ul>
                <p><b>Необходим для:</b></p>
                <ul class="top">
                  <li><i>Повышения доверия клиентов </i>к продукту за счет обеспечения его надежности и соответствия
                    ожиданиям.</li>
                  <li><i>Снижения затрат </i>на исправление дефектов, обнаруженных на поздних этапах разработки или
                    после выпуска продукта.</li>
                  <li><i>Улучшения и оптимизации процессов разработки </i>, что приводит к более эффективному созданию
                    продуктов.</li>
                  <li><i>Соблюдения законодательных и стандартных требований </i>относительно качества продукта.</li>
                </ul>
                <p>Примеры :</p>
                <ul class="top">
                  <li>В процессе разработки программного обеспечения он включает ревью кода, тестирование, управление
                    изменениями, а также использование методик агил и непрерывной интеграции для обеспечения качества
                    продукта.</li>
                  <li>В производстве его может включать стандарты качества для материалов, процессов производства и
                    готовой продукции, а также регулярные инспекции и тестирования продукции.</li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="32">
              <div class="tab__box">
                <p><i>Scrum </i>— это гибкая методология разработки ПО, которая подчёркивает командную работу,
                  обратную
                  связь и быструю адаптацию к изменениям. <br>Она была создана для управления процессом разработки в
                  условиях, когда точные требования к продукту и окончательные результаты могут меняться или не быть
                  полностью известными на начальных этапах проекта.</p>
                <p><i>Scrum </i>— это методология гибкой разработки, которая помогает командам эффективно работать над
                  сложными проектами, регулярно адаптируясь к изменениям и улучшая процесс работы. <br>Это как игра в
                  регби, где команда движется вперёд мячом, передавая его от одного игрока к другому, чтобы достичь
                  цели, несмотря на препятствия.
                </p>
                <p><b>Основные принципы Scrum:</b></p>
                <ul class="top">
                  <li><i>Итеративный подход: </i>Разработка делится на короткие циклы (спринты), продолжительностью
                    обычно от одной до четырёх недель. <br>Каждый спринт включает в себя планирование, разработку,
                    тестирование и демонстрацию готового функционала.</li>
                  <li><i>Самоорганизующиеся команды: </i>Команды состоят из профессионалов, которые самостоятельно
                    распределяют задачи и отвечают за достижение целей спринта. <br>Роли в команде включают Product
                    Owner (владелец продукта), Scrum Master и команду разработчиков.</li>
                  <li><i>Продуктовый бэклог: </i>Список всех известных требований к продукту, приоритизированный
                    владельцем продукта. <br>Эти требования разбиваются на меньшие задачи для выполнения в рамках
                    спринтов.</li>
                  <li><i>Спринтовый бэклог: </i>Список задач, выбранных командой для выполнения в текущем спринте.
                  </li>
                  <li><i>Ежедневные стендапы (Daily Scrum): </i>Короткие ежедневные встречи для координации работы и
                    обсуждения прогресса и возможных препятствий.</li>
                  <li><i>Обзор спринта (Sprint Review): </i>Встреча в конце спринта, где команда демонстрирует что
                    было
                    достигнуто за спринт.</li>
                  <li><i>Ретроспектива спринта: </i>Встреча после обзора спринта, на которой команда обсуждает, что
                    работало хорошо, что можно улучшить, и планирует улучшения на следующий спринт.</li>
                </ul>
                <p><b>Цели Scrum:</b></p>
                <ul class="top">
                  <li><i>Гибкость и адаптивность: </i>Быстро реагировать на изменения требований и условий разработки.
                  </li>
                  <li><i>Прозрачность процесса: </i>Все участники проекта имеют чёткое представление о ходе работы и
                    проблемах.</li>
                  <li><i>Постоянное улучшение: </i>Непрерывная оптимизация процесса разработки и работы команды.</li>
                </ul>
                <p><b>Преимущества Scrum:</b></p>
                <ul class="top">
                  <li>Улучшает коммуникацию и сотрудничество в команде.</li>
                  <li>Повышает качество продукта за счёт регулярного тестирования и обратной связи.</li>
                  <li>Позволяет быстрее реагировать на изменения и новые требования заказчика.</li>
                  <li>Делает процесс разработки более прозрачным и предсказуемым.</li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="33">
              <div class="tab__box">
                <p><i>Тест-план</i> — это документ, который описывает, как будет проводиться тестирование программного
                  продукта, включая цели, задачи, ресурсы, методологии, критерии начала и завершения, управление рисками
                  и процедуры отчетности. <br>Он служит основой для организации и проведения тестирования в проекте.</p>
                <p>Должен быть гибким и адаптироваться к изменениям в проекте, но в то же время он должен обеспечивать
                  достаточный уровень детализации и структурированности для эффективного управления процессом
                  тестирования.
                </p>
                <p><i>Тест-план </i>— это документ, который описывает объем, подход, ресурсы и план тестирования ПО.
                  <br>Он служит руководством для тестирования проекта и включает в себя детали, касающиеся целей
                  тестирования, оценки рисков, методологий тестирования, задач, ответственностей и необходимых ресурсов,
                  а также графика выполнения тестов.
                </p>
                <p>Вот основные компоненты, которые обычно описываются в тест-плане:</p>
                <ul>
                  <li><i>1. Введение: </i>Краткое описание проекта и тестового плана, цели тестирования.</li>
                  <li><i>2. Объекты тестирования: </i>Перечисление компонентов или функциональностей программного
                    обеспечения, которые подлежат тестированию.</li>
                  <li><i>3. Задачи тестирования: </i>Четкое определение задач, которые должны быть выполнены в рамках
                    тестового плана. <br>Это может включать как функциональное, так и нефункциональное тестирование.
                  </li>
                  <li><i>4. Ответственные за тестирование: </i>Список всех участников процесса тестирования с указанием
                    их ролей и ответственности.</li>
                  <li><i>5. Методология тестирования: </i>Описание подходов и методик тестирования, которые будут
                    использоваться для проверки соответствия программного обеспечения требованиям и спецификациям.</li>
                  <li><i>6. Критерии начала и завершения тестирования: </i>Определение условий, при которых начинается и
                    завершается тестирование, включая критерии готовности к тестированию и критерии успешности.</li>
                  <li><i>7. Ресурсы: </i>Перечень всех ресурсов, необходимых для тестирования, включая программное и
                    аппаратное обеспечение, а также любые специфические требования к тестовому окружению.</li>
                  <li><i>8. План и график тестирования: </i>Расписание тестовых мероприятий и оценка времени,
                    необходимого для их выполнения.</li>
                  <li><i>9. Управление рисками: </i>Оценка потенциальных рисков для проекта тестирования с указанием их
                    вероятности и возможных последствий, а также план действий по их минимизации или устранению.</li>
                  <li><i>10. Процедуры отслеживания и отчетности: </i>Описание процесса документирования обнаруженных
                    дефектов, методов отслеживания их статуса, а также процедур подготовки и предоставления отчетов о
                    ходе тестирования.</li>
                  <li><i>11. Предметы и материалы для тестирования: </i>Список всех документов и материалов, которые
                    будут использоваться в процессе тестирования, включая требования, спецификации, руководства
                    пользователя и т.д.</li>
                  <li><i>12. План обучения и подготовки: </i>Если для выполнения тестирования необходимы специальные
                    знания или навыки, в тест-плане указываются мероприятия по обучению и подготовке соответствующих
                    специалистов.</li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="34">
              <div class="tab__box">
                <p><i>Эквивалентное разделение</i> — это важная и полезная техника в области тестирования ПО,
                  позволяющая оптимизировать процесс тестирования за счет сокращения количества тестов при сохранении
                  общего качества тестирования.</p>
                <p><i>Эквивалентное разделение (Equivalence Partitioning)</i> — это техника тестирования ПО,
                  используемая для сокращения количества тестовых случаев, необходимых для полного тестирования
                  функционала, путем разделения данных на эквивалентные группы или классы.</p>
                <p><i>Целью</i> такого разделения является уменьшение общего объема тестирования, сохраняя при этом его
                  эффективность, поскольку предполагается, что обработка одного элемента из каждой группы (или раздела)
                  будет представлять обработку всех элементов этой группы.</p>
                <p><b>Принципы:</b></p>
                <ul class="top">
                  <li><i>Определение эквивалентных классов: </i>Входные данные или условия тестирования разделяют на
                    классы, внутри которых система должна вести себя одинаково. <br>Эти классы могут быть как
                    допустимыми (валидными), так и недопустимыми (невалидными).</li>
                  <li><i>Выбор представителей: </i>Для каждого эквивалентного класса выбирается хотя бы один
                    представитель (тестовый случай), который будет использован в тестировании.</li>
                  <li><i>Тестирование: </i>Проводится тестирование на основе выбранных представителей каждого класса.
                    <br>Результаты тестирования для представителя класса экстраполируются на весь класс.
                  </li>
                </ul>
                <p><b>Пример:</b></p>
                <p>Представим функцию, принимающую возраст пользователя в виде числа от 1 до 100. <br>Здесь можно
                  выделить три эквивалентных класса:</p>
                <ul class="top">
                  <li><i>Допустимый класс: </i>возраст от 1 до 100 (система должна принять значение).</li>
                  <li><i>Недопустимый класс 1: </i>возраст меньше 1 (система должна отклонить значение).</li>
                  <li><i>Недопустимый класс 2: </i>возраст больше 100 (система также должна отклонить значение).</li>
                </ul>
                <p>Выбрав по одному представителю из каждого класса, например, 25 (допустимый возраст), 0 (недопустимый
                  возраст меньше 1) и 101 (недопустимый возраст больше 100), можно эффективно проверить обработку
                  входных данных различными частями программы, минимизировав при этом количество необходимых тестов.</p>
                <p><b>Преимущества:</b></p>
                <ul class="top">
                  <li><i>Эффективность: </i>Позволяет сократить количество тестовых случаев, сохраняя при этом высокий
                    уровень покрытия функционала.</li>
                  <li><i>Экономия времени и ресурсов: </i>Уменьшает время, необходимое на тестирование, и ресурсы,
                    затрачиваемые на подготовку и выполнение тестов.</li>
                </ul>
                <p><b>Ограничения</b></p>
                <ul class="top">
                  <li><i>Не всегда очевидное разделение: </i>В некоторых случаях может быть сложно определить границы
                    эквивалентных классов.</li>
                  <li><i>Может не обнаружить некоторые дефекты: </i>Так как тестирование не всегда покрывает все
                    возможные комбинации входных данных внутри класса.</li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="35">
              <div class="tab__box">
                <p>Техника анализа граничных значений является ключевым компонентом в стратегии тестирования,
                  позволяющим более эффективно идентифицировать потенциальные ошибки в ПО, сосредотачиваясь на
                  критически важных точках входных данных.</p>
                <p>Техника анализа граничных значений (Boundary Value Analysis, BVA) — это метод тестирования ПО,
                  который сосредотачивается на проверке поведения системы на границах допустимых входных данных.
                  <br>Этот метод основан на наблюдении, что ошибки часто происходят на границах диапазонов входных
                  значений, а не внутри диапазонов. <br>Поэтому, приоритетом является тестирование условий на краях
                  диапазона значений, а также непосредственно вне этих границ.
                </p>
                <p><b>Основные принципы:</b></p>
                <ul class="top">
                  <li><i>Тестирование на минимальной и максимальной границе: </i>Если у вас есть диапазон значений от 1
                    до 100, техника BVA предполагает тестирование с использованием значений 1 и 100, так как они
                    представляют собой граничные значения диапазона.</li>
                  <li><i>Тестирование за пределами границ: </i>Помимо тестирования граничных значений внутри диапазона,
                    также рекомендуется тестирование значений непосредственно за границами диапазона, например, 0 и 101
                    в данном случае. <br>Это помогает проверить, как система будет реагировать на недопустимые входные
                    данные.</li>
                  <li><i>Тестирование значений вокруг "особых" точек: </i>Если в спецификациях указаны особые значения
                    (например, ограничения на ввод, при которых изменяется поведение системы), то важно тестировать
                    значения вокруг этих точек.</li>
                </ul>
                <p><b>Пример:</b></p>
                <p>Предположим, у нас есть поле ввода для возраста пользователя, допустимый диапазон которого от 18 до
                  65 лет включительно. <br>Согласно технике анализа граничных значений, следует тестировать следующие
                  значения:</p>
                <ul class="top">
                  <li>17 (значение непосредственно за нижней границей диапазона),</li>
                  <li>18 (нижняя граница диапазона),</li>
                  <li>65 (верхняя граница диапазона),</li>
                  <li>66 (значение непосредственно за верхней границей диапазона).</li>
                </ul>
                <p><b>Почему она важна:</b></p>
                <ul class="top">
                  <li><i>Высокая эффективность: </i>Тестирование граничных значений позволяет обнаружить большое
                    количество ошибок с минимальным количеством тестов.</li>
                  <li><i>Экономия времени и ресурсов: </i>Сосредоточение усилий на наиболее вероятных местах
                    возникновения ошибок позволяет сократить время, необходимое для тестирования, и оптимизировать
                    использование ресурсов.</li>
                  <li><i>Улучшение качества продукта: </i>Помогает гарантировать, что приложение корректно обрабатывает
                    данные на границах допустимых значений, что является критически важным для функциональности и
                    удобства пользователя.</li>
                </ul>
                <p>__________________</p>
                <p>Это техника проверки поведения продукта на крайних (граничных) значениях входных данных.
                  <br>Граничное тестирование также может включать тесты, проверяющие поведение системы на входных
                  данных, выходящих за допустимый диапазон значений. <br>При этом система должна определённым (заранее
                  оговоренным) способом обрабатывать такие ситуации. <br>Например, с помощью исключительной ситуации или
                  сообщения об ошибке.
                </p>
              </div>
            </div>

            <div class="tab-item" id="36">
              <div class="tab__box">
                <a href="https://easyoffer.ru/question/7824">https://easyoffer.ru/question/7824</a>
              </div>
            </div>

            <div class="tab-item" id="37">
              <div class="tab__box">
                <p><i>Тестирование инсталляции (Installation Testing) </i>— это процесс проверки, успешно ли
                  устанавливается, настраивается и запускается приложение или система на целевой платформе или
                  устройстве.
                </p>
                <p>Этот вид тестирования обеспечивает, что пользователи могут без проблем установить и начать
                  использовать продукт в соответствии с предоставленными инструкциями. </p>
                <p>Оно является частью процесса обеспечения качества и помогает выявить возможные проблемы, связанные с
                  процедурой установки, которые могут препятствовать правильной работе программного обеспечения.</p>
                <p><b>Основные аспекты:</b></p>
                <ul class="top">
                  <li><i>Проверка требований: </i>Удостовериться, что все предварительные требования (например,
                    операционная система, оборудование, необходимое программное обеспечение) соответствуют указанным для
                    успешной установки.</li>
                  <li><i>Тестирование различных сценариев установки: </i>Включает полную установку, пользовательскую
                    установку (где пользователи могут выбирать компоненты для установки), обновление с предыдущих версий
                    и, при необходимости, тихую установку (без взаимодействия с пользователем).</li>
                  <li><i>Проверка на разных платформах: </i>Убедиться, что приложение может быть установлено на всех
                    поддерживаемых операционных системах и конфигурациях оборудования.</li>
                  <li><i>Проверка процесса удаления: </i>Тестирование должно также включать проверку того, что
                    приложение может быть полностью удалено, не оставляя за собой никаких файлов или изменений в
                    системе.</li>
                  <li><i>Валидация инструкций по установке: </i>Подтвердить, что документация и инструкции по установке
                    ясны и точны.</li>
                </ul>
                <p><b>Зачем оно нужно?</b></p>
                <ul class="top">
                  <li><i>Улучшение первого впечатления: </i>Проблемы с установкой могут отпугнуть пользователей ещё до
                    того, как они начнут пользоваться приложением.</li>
                  <li><i>Обеспечение совместимости: </i>Гарантирует, что программное обеспечение может быть установлено
                    на всех заявленных платформах и конфигурациях.</li>
                  <li><i>Проверка на разных платформах: </i>Убедиться, что приложение может быть установлено на всех
                    поддерживаемых операционных системах и конфигурациях оборудования.</li>
                  <li><i>Минимизация поддержки: </i>Предотвращение запросов в службу поддержки, связанных с проблемами
                    установки.</li>
                  <li><i>Повышение качества продукта: </i>Часть комплексного подхода к обеспечению качества программного
                    продукта.</li>
                </ul>
                <p>Тестирование инсталляции играет критически важную роль в жизненном цикле разработки ПО, помогая
                  обеспечить, что конечные пользователи смогут без проблем установить продукт и начать его
                  использование, что в конечном итоге влияет на удовлетворенность пользователя и успешность продукта на
                  рынке.</p>
              </div>
            </div>

            <div class="tab-item" id="38">
              <div class="tab__box">
                <p><i>Нефункциональное тестирование </i>— это тип тестирования ПО, направленный на проверку атрибутов
                  системы, которые не связаны напрямую с конкретными функциями или функциональными требованиями.</p>
                <p>Это включает в себя тестирование <i>производительности, безопасности, удобства использования и других
                    аспектов</i>, которые влияют на качество продукта, но не относятся к его функциональности. </p>
                <p>Оно помогает обеспечить, что программное обеспечение будет работать эффективно, безопасно и удобно
                  для пользователя в различных условиях.</p>
                <p><b>Виды:</b></p>
                <ul>
                  <li><i>1. Тестирование производительности: </i>Проверяет, насколько хорошо система выполняет
                    определенные процессы и операции в заданных условиях. Включает в себя тестирование на нагрузку,
                    стресс-тестирование, тестирование стабильности и тестирование масштабируемости.</li>
                  <li><i>2. Тестирование безопасности: </i>Оценивает, насколько хорошо система защищена от внутренних и
                    внешних угроз безопасности. <br>Это включает в себя поиск уязвимостей, тестирование на
                    проникновение, аудит кода на предмет безопасности и тестирование аутентификации и авторизации.</li>
                  <li><i>3. Тестирование удобства использования (юзабилити): </i>Оценивает, насколько легко конечные
                    пользователи могут использовать продукт для достижения своих целей. <br>Включает в себя тестирование
                    интерфейса, легкости обучения, эффективности использования и удовлетворенности пользователя.</li>
                  <li><i>4. Тестирование совместимости: </i>Проверяет, как программное обеспечение работает и
                    взаимодействует с другими компонентами системы, включая различные браузеры, операционные системы,
                    базы данных и сетевые среды.</li>
                  <li><i>5. Тестирование надежности: </i>Оценивает способность программного обеспечения выполнять
                    требуемые функции под определенными условиями в течение определенного периода времени без сбоев.
                  </li>
                  <li><i>6. Тестирование доступности: </i>Проверяет, насколько легко люди с ограниченными возможностями
                    могут использовать продукт. <br>Это включает в себя проверку соответствия стандартам и рекомендациям
                    по доступности.</li>
                </ul>
                <p><b>Зачем оно нужно?</b></p>
                <p>Критически важно для обеспечения качества ПО, поскольку оно помогает убедиться, что продукт будет
                  работать удовлетворительно в реальных условиях эксплуатации.</p>
                <p>Оно обеспечивает:</p>
                <ul class="top">
                  <li>Высокую производительность и быстродействие приложения.</li>
                  <li>Защиту от внешних и внутренних угроз безопасности.</li>
                  <li>Удобство и простоту использования для конечных пользователей.</li>
                  <li>Совместимость с различными устройствами, ОС и браузерами.</li>
                  <li>Надежность и стабильность работы в различных условиях.</li>
                  <li>Доступность для пользователей с ограниченными возможностями.</li>
                </ul>
                <p>В современной разработке ПО нефункциональное тестирование занимает такое же важное место, как и
                  функциональное, поскольку оно напрямую влияет на пользовательский опыт, безопасность и
                  удовлетворенность клиентов.</p>
                <p>__________________</p>
                <p>Нефункциональное тестирование включает:</p>
                <ul class="top">
                  <li>Тестирование производительности – работа ПО под определённой нагрузкой.</li>
                  <li>Тестирование пользовательского интерфейса – удобство пользователя при взаимодействии с разными
                    параметрами интерфейса (кнопки, цвета, выравнивание и т. д.).</li>
                  <li>Тестирование UX – правильность логики использования программного продукта.</li>
                  <li>Тестирование защищенности – определение безопасности ПО: защищено ли оно от атак хакеров,
                    несанкционированного доступа к данным и т. д.</li>
                  <li>Инсталляционное тестирование – оценка вероятности возникновения проблем при установке, удалении, а
                    также обновлении ПО.</li>
                  <li>Тестирование совместимости – тестирование работы программного продукта в определённом окружении.
                  </li>
                  <li>Тестирование надежности – работа программы при длительной средней ожидаемой нагрузке.</li>
                  <li>Тестирование локализации –оценка правильности версии программного продукта (языковой и культурный
                    аспекты).</li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="39">
              <div class="tab__box">
                <p>Существует несколько типов баз данных, каждый из которых предназначен для решения определённых задач
                  и имеет свои особенности.</p>
                <p>Выбор зависит от специфики проекта, требований к хранению и обработке данных, а также от
                  предпочтений.</p>
                <p>Вот некоторые из наиболее распространённых типов:</p>
                <ul>
                  <li><i>1. Реляционные базы данных (RDBMS) </i><br>Это самый традиционный, где данные хранятся в
                    таблицах, а отношения между данными определяются с помощью ключей. <br>Реляционные базы данных
                    используют язык SQL для создания, модификации, управления и запроса данных. <br>Примеры включают
                    PostgreSQL, MySQL, Oracle и Microsoft SQL Server.</li>
                  <li><i>2. Нереляционные базы данных (NoSQL) </i><br>NoSQL-базы данных предлагают более гибкую схему
                    данных
                    и часто используются для хранения неструктурированных или полуструктурированных данных. <br>Они
                    могут быть подразделены на несколько типов:
                    <ul class="top">
                      <li><i>Документо-ориентированные: </i>Хранят информацию в формате JSON, BSON или XML. Примеры:
                        MongoDB, CouchDB.</li>
                      <li><i>Ключ-значение: </i>Данные хранятся в виде пар ключ-значение. Примеры: Redis, DynamoDB.</li>
                      <li><i>Графовые базы данных: </i>Специализированные на хранении и обработке графов (сетей) данных.
                        Примеры: Neo4j, Amazon Neptune.</li>
                      <li><i>Базы данных широких столбцов: </i>Оптимизированы для чтения и записи больших объёмов
                        данных. Примеры: Cassandra, HBase.</li>
                    </ul>
                  </li>
                  <li><i>3. Объектно-ориентированные базы данных </i><br>В таких БД информация хранится в виде объектов,
                    а
                    не в таблицах. <br>Это позволяет использовать в базе данных те же концепции, что и в
                    объектно-ориентированном программировании. <br>Примеры: db4o, ObjectDB.</li>
                  <li><i>4. Иерархические базы данных </i><br>Данные организованы в структуру дерева, где каждый элемент
                    имеет одного родителя и может иметь множество детей. <br>Этот тип был популярен в ранние годы
                    развития баз данных, но сейчас используется реже.</li>
                  <li><i>5. Сетевые базы данных </i><br>Подобно иерархическим, но каждый элемент может иметь несколько
                    родителей. <br>Это позволяет создавать более сложные отношения между данными.</li>
                  <li><i>6. Распределённые базы данных </i><br>Это системы, которые управляют данными, распределёнными
                    по нескольким местам, будь то на разных серверах или в разных географических локациях.
                    Распределённые базы данных обеспечивают высокую доступность и масштабируемость. <br>Примеры:
                    Cassandra, CockroachDB.</li>
                  <li><i>7. Временные ряды базы данных </i><br>Специализированный тип баз данных, оптимизированный для
                    хранения и анализа последовательностей данных, измеренных через равные промежутки времени.
                    <br>Примеры: InfluxDB, TimescaleDB.
                  </li>
                </ul>
                <p>Выбор типа базы данных зависит от множества факторов, включая требования к производительности, тип и
                  структуру данных, масштабируемость, доступность и консистентность данных.</p>
              </div>
            </div>

            <div class="tab-item" id="40">
              <div class="tab__box">
                <p><i>SQL</i> — это язык программирования для управления данными в реляционных базах данных.</p>
                <p>Он позволяет выполнять операции выборки, вставки, обновления и удаления данных, а также управлять
                  структурой баз данных и доступом к ним.</p>
                <p>SQL является мощным и универсальным инструментом в руках разработчиков и аналитиков данных.</p>
                <p>__________________</p>
                <p><i>SQL, или Structured Query Language (Структурированный язык запросов),</i>— это стандартизированный
                  язык, используемый для управления реляционными базами данных и выполнения различных операций с данными
                  в них. </p>
                <p>Он позволяет выполнять запросы к базе данных, чтобы извлекать, обновлять, вставлять и удалять данные.
                </p>
                <p>Он также используется для создания и модификации структуры базы данных, а также управления данными и
                  доступом к ним.</p>
                <p><b>Основные характеристики:</b></p>
                <ul class="top">
                  <li><i>Универсальность: </i>Является стандартным языком для всех реляционных баз данных, что означает,
                    что знание SQL позволяет работать с большинством современных систем управления базами данных, таких
                    как MySQL, PostgreSQL, SQL Server, Oracle и многих других.</li>
                  <li><i>Декларативность: </i>В отличие от процедурных языков программирования, в нем вы описываете, что
                    хотите сделать, а не как достичь этого результата. <br>Это делает его относительно легким для
                    изучения и использования.</li>
                  <li><i>Мощность: </i>Обладает большими возможностями для выполнения сложных запросов, включая операции
                    соединения таблиц, агрегации данных и подзапросы, что позволяет эффективно обрабатывать большие
                    объемы данных.</li>
                </ul>
                <p><b>Основные операции:</b></p>
                <ul class="top">
                  <li><i>SELECT: </i>Извлечение данных из одной или нескольких таблиц.</li>
                  <li><i>INSERT: </i>Вставка новых данных в таблицу.</li>
                  <li><i>UPDATE: </i>Обновление существующих данных в таблице</li>
                  <li><i>DELETE: </i>Удаление данных из таблицы.</li>
                  <li><i>CREATE DATABASE/TABLE: </i>Создание новой базы данных или таблицы.</li>
                  <li><i>ALTER TABLE: </i>Модификация структуры существующей таблицы, например, добавление или удаление
                    столбцов.</li>
                  <li><i>DROP DATABASE/TABLE: </i>Удаление базы данных или таблицы.</li>
                </ul>
                <p>Примеры:</p>
                <ul class="top">
                  <li><i>1. SELECT: </i>Выбрать всех пользователей из таблицы <i>`users`</i>.</li>
                  <li class="top__span"><b>SELECT</b><span>*</span><b>FROM </b> users;</li>
                  <li><i>2. INSERT: </i>Добавить нового пользователя в таблицу <i>`users`</i>.</li>
                  <li class="top__span"><b>INSERT INTO </b> users (username, email) <b> VALUES </b><span>('newuser',
                      'newuser@example.com')</span> ;</li>
                  <li><i>3. UPDATE: </i>Обновить адрес электронной почты пользователя в таблице <i>`users`</i>.</li>
                  <li class="top__span"><b>UPDATE </b> users <b>SET </b> email<span>=
                      'updateduser@example.com'</span><b>WHERE </b> username <span>= 'newuser'</span> ;</li>
                  <li><i>4. DELETE: </i>Удалить пользователя из таблицы <i>`users`</i> .</li>
                  <li class="top__span"><b>DELETE FROM</b> users <b>WHERE </b>username <span>= 'newuser'</span> ;</li>
                </ul>
                <p>Играет ключевую роль в разработке и поддержке реляционных баз данных, обеспечивая эффективное
                  управление данными и их анализ.</p>
              </div>
            </div>

            <div class="tab-item" id="41">
              <div class="tab__box">
                <p>Операция <i>JOIN </i> используется для объединения строк двух или более таблиц, основываясь на общем
                  столбце между ними, который обычно является ключевым столбцом. <br>Это мощный инструмент для
                  извлечения связанных данных из разных таблиц. <br>Есть несколько его типов, каждый из которых
                  применяется для решения определённых задач.</p>
                <p><b>INNER JOIN</b> <br>Возвращает строки, когда есть хотя бы одно совпадение в обеих таблицах.
                  <br>Если "совпадений" нет, то результаты не будут включены в итоговый набор.
                </p>
                <p><b>Пример:</b></p>
                <ul class="top">
                  <li class="top__span"><b>SELECT</b> Orders.OrderID, Customers.CustomerName
                    <br><b> FROM </b> Orders <br> <b> INNER JOIN </b> Customers <b> ON </b>
                    Orders.CustomerID <span> = </span> Customers.CustomerID;
                  </li>
                </ul>
                <p>Этот запрос возвращает список заказов вместе с именами клиентов, но только для тех заказов, у которых
                  есть соответствие в таблице клиентов.</p>
                <p><b>LEFT JOIN (или LEFT OUTER JOIN)</b></p>
                <p>Возвращает все строки из левой таблицы (таблицы, указанной перед JOIN), и совпадающие строки из
                  правой таблицы. <br>Для строк из левой таблицы, для которых нет совпадений в правой таблице, результат
                  будет содержать NULL на месте столбцов правой таблицы.</p>
                <p><b>Пример:</b></p>
                <ul class="top">
                  <li class="top__span"><b>SELECT</b> Orders.OrderID, Customers.CustomerName
                    <br><b> FROM </b> Orders <br> <b> LEFT JOIN </b> Customers <b> ON </b>
                    Orders.CustomerID <span> = </span> Customers.CustomerID;
                  </li>
                </ul>
                <p>Этот запрос возвращает список всех заказов вместе с именами клиентов. <br>Если для заказа нет
                  клиента, имя клиента будет NULL.</p>
                <p><b>RIGHT JOIN (или RIGHT OUTER JOIN)</b></p>
                <p>Работает аналогично <b>`LEFT JOIN`</b> , но возвращает все строки из правой таблицы, и совпадающие
                  строки из
                  левой таблицы. <br>Для строк из правой таблицы, для которых нет совпадений в левой таблице, результат
                  будет содержать NULL на месте столбцов левой таблицы.</p>
                <p><b>Пример:</b></p>
                <ul class="top">
                  <li class="top__span"><b>SELECT</b> Orders.OrderID, Customers.CustomerName
                    <br><b> FROM </b> Orders <br> <b> RIGHT JOIN </b> Customers <b> ON </b>
                    Orders.CustomerID <span> = </span> Customers.CustomerID;
                  </li>
                </ul>
                <p>Этот запрос возвращает список всех клиентов вместе с заказами. <br>Если у клиента нет заказов,
                  OrderID будет NULL.</p>
                <p><b>FULL JOIN (или FULL OUTER JOIN)</b></p>
                <p>Возвращает строки, когда существует совпадение хотя бы в одной из таблиц. <br>То есть, он возвращает
                  все строки из обеих таблиц, соединяя их там, где это возможно, и помещая NULL на местах без
                  совпадений.</p>
                <p><b>Пример:</b></p>
                <ul class="top">
                  <li class="top__span"><b>SELECT</b> Orders.OrderID, Customers.CustomerName
                    <br><b> FROM </b> Orders <br> <b> FULL JOIN </b> Customers <b> ON </b>
                    Orders.CustomerID <span> = </span> Customers.CustomerID;
                  </li>
                </ul>
                <p>Этот запрос возвращает список всех заказов и всех клиентов, соединяя их там, где есть совпадения по
                  CustomerID.</p>
                <p><b>CROSS JOIN</b></p>
                <p>Создает декартово произведение двух таблиц, т.е., он возвращает все возможные комбинации строк из
                  обеих таблиц. <br>Этот тип JOIN не требует условия соединения.</p>
                <p><b>Пример:</b></p>
                <ul class="top">
                  <li class="top__span"><b>SELECT</b> Orders.OrderID, Customers.CustomerName
                    <br><b> FROM </b> Orders <br> <b> CROSS JOIN </b> Customers <b> ON </b>
                    Orders.CustomerID <span> = </span> Customers.CustomerID;
                  </li>
                </ul>
                <p>Этот запрос возвращает все возможные комбинации клиентов и продуктов.</p>
                <p>Каждый тип JOIN используется в зависимости от задачи: чтобы получить только совпадающие строки из
                  обеих таблиц, используется <b>`INNER JOIN`</b>; чтобы получить все строки из одной таблицы и
                  совпадающие из другой, применяется <b>`LEFT JOIN`</b> или <b>`RIGHT JOIN`</b>; <b>`FULL JOIN`</b>
                  позволяет получить полное соединение двух таблиц, а <b>`CROSS JOIN`</b> — декартово произведение строк
                  таблиц.</p>
                <p>__________________</p>
                <p><i>SQL Join</i> – одна из наиболее часто используемых команд в SQL-синтаксисе. <br>Она используется
                  для поиска информации в базах данных по заранее определенным критериям. <br>В частности, Join отвечает
                  за объединение нескольких групп данных в единый поток информации. <br>И это действительно необходимо,
                  потому что в 100% случаев контент в реляционных базах данных с поддержкой SQL-синтаксиса делится на
                  множество таблиц, фильтровать данные, в которых можно с помощью специальных команд и запросом
                  информации из общего пула таблиц. <br>SQL Join помогает настроить фильтр поиска в базе данных,
                  опираясь на взаимосвязи между различными элементами БД и их отличительные черты (теги, ID,
                  наименования и т. п.).</p>
                <p><b>SQL Inner Join</b></p>
                <p>Этот режим объединения результатов поиска в базах данных SQL включается автоматически. <br>Если вы не
                  укажете намеренно тип Join, то сработает именно Inner Join. <br>С помощью него можно указать сразу два
                  критерия (две таблицы) и по ним отсеять контент. </p>
                <p>Достаточно прописать SQL-запрос в духе:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> table<span>-1</span>
                    <br><b>
                      JOIN
                    </b> table<span>-2</span> <b>ON</b>
                    table<span>-1.</span>parameter<span>=</span>table<span>-2.</span>parameter <br><b>WHERE</b> table
                    <span>-1.</span>parameter IS ‘myData’
                  </li>
                </ul>
                <p>Фактически мы пытаемся выудить данные из первой таблицы и объединить их с данными из второй таблицы,
                  при этом фильтруя только те записи, в которых совпадает значение параметра. В первой таблице оно
                  приравнивается к myData.</p>
                <p>На практике это может использоваться на сайте с музыкальными инструментами, например. <br>Можно
                  запрашивать гитары конкретного бренда, при этом еще и выбирая дополнительное условие в духе количества
                  струн.</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> SevenStringGuitars
                    <br><b> JOIN </b> Ibanez <b> ON </b> SevenStringGuitar.brandId<span>=</span>Ibanez.brandId
                  </li>
                </ul>
                <p>Таким SQL-запросом мы можем отфильтровать все инструменты бренда Ibanez в категории «Гитары» с 7
                  струнами. </p>
                <p><b>Left</b></p>
                <p>Левое объединение подразумевает как раз вышеописанный сценарий. <br>Когда мы берем одну таблицу,
                  подключаем вторую и при этом показываем не только точные совпадения, но еще и весь список строк,
                  полученных из левой таблицы, для которых не нашлось пары в правой таблице.</p>
                <p>На практике это может выглядеть так:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> table1
                    <br><b>LEFT JOIN </b> table2 <b> ON </b> table1.parameter<span>=</span>table2.parameter
                  </li>
                </ul>
                <p>Теперь мы объединяем первую и вторую таблицу, доставая информацию как о совпадениях по заданным
                  параметрам, так и по контенту без пары в левой таблице. <br>При желании, надстраивая подобный фильтр,
                  можно вовсе исключить целую категорию строк:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> table1
                    <br><b>LEFT JOIN </b> table2 <b> ON </b> table1.parameter<span>=</span>table2.parameter
                    <br><b>WHERE</b> table2.parameter <b>IS NULL</b>
                  </li>
                </ul>
                <p>На живом примере фильтрация такого рода может выглядеть так:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> Russian
                    <br><b>LEFT JOIN </b> Rap <b> ON </b> Russian.genreId<span>=</span>Rap.genreId
                  </li>
                </ul>
                <p>Представим, что мы запустили продвинутый поиск на сайте с музыкальными альбомами. <br>Мы хотим
                  послушать что-то на русском языке. Причем готовы даже оценить качество отечественного рэпа. <br>При
                  этом в целом мы рэп не любим и не хотим, чтобы он попадался на каких-то других языках.</p>
                <p><b>Right</b></p>
                <p>Понятно, что правое объединение будет работать в обратную сторону и покажет элементы из правой
                  таблицы, для которых не нашлось пары в левой. </p>
                <p>Получится следующий SQL-запрос:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> table1
                    <br><b>RIGHT JOIN </b> table2 <b> ON </b> table1.parameter<span>=</span>table2.parameter
                  </li>
                </ul>
                <p>Если взять пример из предыдущей главы, то в реальности можно обернуть ситуацию в противоположную
                  сторону. <br>Искать только рэп-музыку, исключив все русское, кроме хип-хопа. <br>Получится что-то в
                  духе:</p>
                <ul class="top">
                  <li class="top__span span-top"><b>SELECT</b> <span>*</span> <br> <b> FROM </b> Russian
                    <br><b>RIGHT JOIN </b> Rap <b> ON </b> Russian.genreIdsp<span>=</span>Rap.genreId
                  </li>
                </ul>
              </div>
            </div>

            <div class="tab-item" id="42">
              <div class="tab__box">
                <p><i>REST API (Representational State Transfer Application Programming Interface)</i> — это
                  архитектурный стиль взаимодействия компонентов распределенной системы через интернет.</p>
                <p>Он предлагает набор ограничений для создания веб-сервисов, которые используют стандартные HTTP-методы
                  для обмена данными между клиентом и сервером.</p>
                <p>Этот стиль был введен Роем Филдингом в его докторской диссертации в 2000 году и быстро стал
                  популярным благодаря своей простоте, масштабируемости и гибкости.</p>
                <p><b>Основные принципы:</b></p>

                <ul>
                  <li><i>1. Клиент-серверная архитектура:</i> Разделение ответственности между клиентом (который
                    запрашивает данные) и сервером (который предоставляет данные) улучшает масштабируемость и упрощает
                    компоненты.</li>
                  <li><i>2. Без сохранения состояния (Stateless): </i>Каждый запрос от клиента к серверу должен
                    содержать всю необходимую информацию для его выполнения. <br>Сервер не сохраняет состояние клиента
                    между запросами, что упрощает архитектуру.</li>
                  <li><i>3. Кэширование: </i>Ответы сервера должны быть явно помечены как кэшируемые или некэшируемые,
                    что уменьшает нагрузку на сервер и улучшает производительность за счет уменьшения задержки ответа.
                  </li>
                  <li><i>4. Единообразный интерфейс: </i>Определяет интерфейс взаимодействия между клиентом и сервером,
                    упрощая и декапсулируя архитектуру системы.</li>
                  <li><i>5. Система слоев: </i>Клиент не может знать, общается ли он непосредственно с сервером или с
                    промежуточным узлом, что улучшает масштабируемость системы за счет использования балансировщиков
                    нагрузки, кэшей и т.д.</li>
                  <li><i>6. Код по требованию (необязательно): </i>Сервер может временно расширять или настраивать
                    функциональность клиента, передавая ему исполняемый код.</li>
                </ul>
                <p><b>Особенности:</b></p>
                <ul class="top">
                  <li>Использование стандартных HTTP-методов: <br>Таких как GET для получения данных, POST для создания
                    новых ресурсов, PUT для обновления существующих ресурсов, DELETE для удаления ресурсов и т.д.</li>
                  <li>Работа с ресурсами: <br>Каждый уникальный URL представляет собой некий ресурс, который может быть
                    представлен в формате JSON, XML или других форматах.</li>
                  <li>Безопасность и авторизация: <br>Хотя он сам по себе не определяет механизмов безопасности, обычно
                    используются стандартные методы, такие как HTTPS, OAuth и токены JSON Web Token (JWT) для
                    обеспечения безопасности данных и авторизации доступа.</li>
                </ul>
                <p>REST API широко используется для создания веб-сервисов благодаря своей простоте, возможности
                  масштабирования и поддержке стандартных HTTP-операций, делая его популярным выбором для разработки
                  современных веб-приложений и микросервисов.</p>
                <p>__________________</p>
                <p>Архитектурный стиль взаимодействия компонентов распределённого приложения в сети. <br>Другими
                  словами, REST — это набор правил того, как программисту организовать написание кода серверного
                  приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.
                  <br>REST представляет собой согласованный набор ограничений, учитываемых при проектировании
                  распределённой гипермедиа-системы. <br>В определённых случаях (интернет-магазины, поисковые системы;
                  прочие системы, основанные на данных) это приводит к повышению производительности и упрощению
                  архитектуры. В широком смысле, компоненты в REST взаимодействуют наподобие взаимодействия клиентов и
                  серверов во Всемирной паутине. <br>REST является альтернативой RPC.
                </p>
                <p>В интернете вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или
                  POST; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве параметров
                  запроса.</p>
                <p>Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений),
                  применяют термин «RESTful».</p>
              </div>
            </div>

            <div class="tab-item" id="44">
              <div class="tab__box">
                <p><i>DevTools, или инструменты разработчика </i>— это набор инструментов встроенных в современные
                  веб-браузеры (например, Google Chrome, Firefox, Safari и Edge), предназначенных для анализа, отладки и
                  профилирования веб-приложений. </p>
                <p>Они предоставляют разработчикам веб-сайтов и веб-приложений удобные средства для изучения и изменения
                  HTML, CSS и JavaScript кода в реальном времени, а также для мониторинга сетевых запросов, проверки
                  производительности страницы, анализа использования памяти и многое другое.</p>
                <p>Основные функции:</p>
                <ul class="top">
                  <li><i>Элементы (Elements): </i>Позволяет просматривать и редактировать HTML и CSS, отображая текущее
                    состояние DOM (Document Object Model) и стили, применённые к выбранным элементам страницы.</li>
                  <li><i>Консоль (Console): </i>Интерактивная консоль для просмотра сообщений, вывода диагностической
                    информации и выполнения JavaScript кода в контексте открытой вкладки.</li>
                  <li><i>Сеть (Network): </i>Отображает информацию о сетевой активности, включая запросы к ресурсам,
                    заголовки запросов и ответов, а также времена загрузки, что помогает оптимизировать загрузку
                    ресурсов и устранять задержки.</li>
                  <li><i>Источники (Sources): </i>Инструмент для отладки JavaScript, позволяющий просматривать файлы
                    исходного кода, устанавливать точки останова и шагать по коду во время выполнения.</li>
                  <li><i>Производительность (Performance): </i>Анализирует время загрузки страницы и производительность
                    выполнения скриптов, помогая выявить узкие места и оптимизировать скорость работы приложения.</li>
                  <li><i>Память (Memory): </i>Инструменты для профилирования использования памяти веб-приложением,
                    выявления утечек памяти и оптимизации расхода ресурсов./li>
                  <li><i>Application: </i>Предоставляет детальную информацию о хранимых данных веб-приложения, включая
                    куки, локальное хранилище (LocalStorage), сессионное хранилище (SessionStorage), кэшированные данные
                    и базы данных.</li>
                </ul>
                <p>DevTools значительно облегчают процесс разработки и отладки веб-приложений, позволяя разработчикам
                  тестировать и анализировать свои приложения непосредственно в браузере, без необходимости постоянно
                  вносить изменения в код и перезагружать страницу. <br>Эти инструменты также включают функции для
                  эмуляции различных устройств и сетевых условий, что позволяет тестировать адаптивность и
                  производительность веб-приложений в разнообразных условиях.</p>
              </div>
            </div>

            <div class="tab-item" id="45">
              <div class="tab__box">
                <p>В конце спринта в методологии Agile, особенно в Scrum, происходят несколько ключевых событий, которые
                  помогают команде оценить проделанную работу, представить результаты заинтересованным сторонам и
                  планировать будущие действия.</p>
                <p>Эти события включают в себя:</p>
                <ul>
                  <li><i>1. Спринт-ревью (Sprint Review)</i><br>На встрече спринт-ревью команда демонстрирует продукт
                    или достигнутые результаты работы за спринт заинтересованным сторонам (stakeholders). <br>Это
                    позволяет получить обратную связь и определить, что еще нужно улучшить или изменить в продукте.
                    <br>Спринт-ревью не является формальным "показом достижений"; скорее, это рабочая сессия, нацеленная
                    на обсуждение и планирование следующих шагов.
                  </li>
                  <li><i>2. Спринт-ретроспектива (Sprint Retrospective)</i><br>После спринт-ревью команда проводит
                    ретроспективу спринта, чтобы обсудить, что хорошо работало, что могло бы быть улучшено и какие
                    действия можно предпринять для улучшения процессов в следующем спринте. Ретроспектива способствует
                    непрерывному улучшению рабочего процесса команды. <br>В отличие от ревью, ретроспектива фокусируется
                    на процессе работы, а не на продукте.</li>
                  <li><i>3. Планирование следующего спринта (Sprint Planning)</i><br>Хотя планирование следующего
                    спринта технически является началом нового спринта, подготовка к нему часто начинается уже в конце
                    текущего спринта. <br>На встрече по планированию спринта команда выбирает задачи из продуктового
                    бэклога, которые они собираются выполнить в следующем спринте, исходя из приоритетов продукта и
                    обратной связи от заинтересованных сторон.</li>
                  <li><i>4. Обновление бэклога продукта</i><br>На основе обратной связи, полученной во время
                    спринт-ревью, и выводов из ретроспективы продуктовый владелец (Product Owner) может внести изменения
                    в бэклог продукта. <br>Это может включать переприоритизацию существующих задач, добавление новых
                    задач или удаление задач, которые больше не считаются релевантными.</li>
                </ul>
                <p>Эти события в конце спринта обеспечивают цикл непрерывного обучения и адаптации, который является
                  ключевым принципом Agile. <br>Они позволяют команде регулярно проверять свой прогресс по отношению к
                  целям продукта, а также адаптировать рабочий процесс и продукт на основе реальных потребностей и
                  изменений во внешней среде. <br>Это способствует повышению продуктивности команды, улучшению качества
                  продукта и удовлетворенности клиентов.</p>
              </div>
            </div>

            <div class="tab-item" id="48">
              <div class="tab__box">
                <p>
                  Критерии начала тестирования, также известные как критерии входа (entry criteria), определяют условия,
                  которые должны быть выполнены, прежде чем начнется фаза тестирования в процессе разработки ПО. <br>Они
                  помогают гарантировать, что тестирование начинается только тогда, когда продукт или его часть
                  достаточно стабильны и готовы к тестовому анализу, что способствует более эффективному и
                  организованному процессу тестирования. <br>Определение четких критериев начала помогает сократить риск
                  недопонимания и неэффективного использования ресурсов тестирования.
                </p>
                <p>Вот несколько общих критериев начала тестирования:</p>
                <ul>
                  <li><i>1. Завершение разработки </i><br>Разработка основного функционала или определенной части
                    продукта должна быть завершена. <br>Это включает в себя кодирование и первичное объединение
                    компонентов системы.</li>
                  <li><i>2. Доступность тестовой среды </i><br>Тестовая среда, в которой будет проводиться тестирование,
                    должна быть полностью настроена и готова к использованию, включая настройку оборудования,
                    программного обеспечения и сетевой инфраструктуры.</li>
                  <li><i>3. Доступность тестовых данных</i><br>Необходимые тестовые данные должны быть подготовлены и
                    доступны для использования в тестах. <br>Это может включать в себя данные для баз данных, файлы для
                    загрузки и другие ресурсы.</li>
                  <li><i>4. Готовность тестовой документации</i><br>Тестовые планы, тест-кейсы и чек-листы должны быть
                    разработаны и утверждены. <br>Документация должна полностью отражать предполагаемый объем
                    тестирования.</li>
                  <li><i>5. Доступность инструментов тестирования</i><br>Все необходимые инструменты и программное
                    обеспечение для тестирования должны быть установлены и настроены, включая системы управления
                    тестированием, инструменты автоматизации тестов и системы отслеживания дефектов.</li>
                  <li><i>6. Обучение персонала</i><br>Тестировщики и другие участники процесса должны быть должным
                    образом обучены и знакомы с продуктом, инструментами тестирования и процессами.</li>
                  <li><i>7. Утверждение заинтересованных сторон</i><br>Необходимо получить подтверждение от
                    заинтересованных сторон о готовности продукта к тестированию, что может включать в себя менеджеров
                    проекта, разработчиков и продуктовых владельцев.</li>
                </ul>
                <p>Определение и соблюдение критериев начала тестирования позволяют избежать многих проблем, связанных с
                  преждевременным началом тестирования, когда продукт еще не готов, что может привести к ненужной
                  переработке и потере времени. <br>Критерии начала обеспечивают, что тестирование будет проведено
                  эффективно, с минимальным количеством прерываний и переработок.</p>
              </div>
            </div>

            <div class="tab-item" id="49">
              <div class="tab__box">
                <p>Тестирование <i>"серого ящика" (Grey Box Testing)</i> представляет собой гибридный подход к
                  тестированию ПО, который сочетает в себе элементы тестирования "черного ящика" и "белого ящика". </p>
                <p>При тестировании <i>"черного ящика"</i> тестировщик сосредотачивается на внешнем поведении системы,
                  не зная её внутреннего устройства, <br>в то время как при тестировании <i>"белого ящика"</i>
                  тестировщик имеет доступ к внутренней структуре, коду и алгоритмам приложения.</p>
                <p><b>Особенности:</b></p>
                <ul class="top">
                  <li><i>Частичное знание внутренней структуры: </i>Тестировщик имеет ограниченный доступ к внутренней
                    структуре и коду программы. <br>Это может включать схемы баз данных, алгоритмы, диаграммы классов и
                    т.д.</li>
                  <li><i>Сочетание методик: </i>Использует методы как тестирования "черного ящика", так и "белого ящика"
                    для более эффективного выявления ошибок и недочетов.</li>
                  <li><i>Целенаправленное тестирование: </i>Позволяет выполнять более целенаправленное тестирование на
                    основе понимания архитектуры и потенциальных слабых мест системы.</li>
                  <li><i>Безопасность и интеграция: </i>Часто используется для тестирования безопасности и
                    интеграционного тестирования, где важно понимание взаимодействия компонентов системы.</li>
                </ul>
                <p><b>Преимущества:</b></p>
                <ul class="top">
                  <li><i>Эффективность: </i>Позволяет более эффективно планировать тесты, зная архитектуру системы.</li>
                  <li><i>Выявление специфических ошибок: </i>Упрощает обнаружение ошибок, связанных с внутренним
                    взаимодействием компонентов системы.</li>
                  <li><i>Комплексный подход: </i>Предоставляет комплексный подход к тестированию, объединяя понимание
                    внутренней логики с тестированием функциональности.</li>
                  <li><i>Безопасность: </i>Особенно эффективен для выявления уязвимостей безопасности, поскольку знание
                    архитектуры помогает в идентификации потенциальных точек риска.</li>
                </ul>
                <p><b>Пример:</b></p>
                <p>Предположим, что тестировщик работает с веб-приложением и знает структуру его базы данных. <br>Это
                  знание позволяет ему создать тесты, направленные на проверку корректности обработки данных
                  приложением, например, тестирование реакции системы на некорректные или неожиданные данные, введенные
                  пользователем, исходя из знания ограничений базы данных.</p>
                <p>Тестирование "серого ящика" является мощным инструментом в арсенале специалистов по качеству
                  программного обеспечения, поскольку оно позволяет сочетать глубокое понимание системы с эффективным
                  функциональным тестированием, обеспечивая таким образом высокий уровень качества и безопасности
                  разрабатываемых продуктов.</p>
              </div>
            </div>

            <div class="tab-item" id="50">
              <div class="tab__box">
                <p>Статусные коды HTTP представляют собой стандартизированные индикаторы, отправляемые сервером в ответ
                  на запросы клиента, чтобы указать на результат обработки запроса. <br>Они помогают определить, был ли
                  запрос успешным, произошла ли ошибка и какого рода действия требуется предпринять дальше.
                </p>
                <p>Они разделены на пять классов:</p>
                <p><b>1xx: Информационные</b></p>
                <ul class="top">
                  <li><i>100 Continue: </i>Промежуточный ответ, указывающий, что начальная часть запроса принята и
                    клиент может продолжать отправку данных.</li>
                  <li><i>101 Switching Protocols: </i>Сервер соглашается переключить протоколы в соответствии с запросом
                    клиента, отправленным в заголовке Upgrade</li>
                </ul>
                <p><b>2xx: Успешные</b></p>
                <ul class="top">
                  <li><i>200 OK: </i>Стандартный ответ для успешных HTTP-запросов. <br>Ресурс успешно обработан и
                    передан в теле ответа.</li>
                  <li><i>201 Created: </i>Запрос был успешно выполнен, и в результате был создан новый ресурс.</li>
                  <li><i>204 No Content: </i>Запрос успешно обработан, но в ответе нет содержимого.</li>
                </ul>
                <p><b>3xx: Перенаправления</b></p>
                <ul class="top">
                  <li><i>301 Moved Permanently: </i>Запрашиваемый ресурс был окончательно перемещен на URL, указанный в
                    заголовке Location. <br>Клиент должен использовать этот новый URL в будущем.</li>
                  <li><i>302 Found: </i>Запрашиваемый ресурс временно находится по другому URI, указанному в заголовке
                    Location.</li>
                  <li><i>304 Not Modified: </i>Ресурс не был изменен с момента последнего запроса клиента, использующего
                    условные заголовки типа If-Modified-Since или If-None-Match.</li>
                </ul>
                <p><b>4xx: Ошибки клиента</b></p>
                <ul class="top">
                  <li><i>400 Bad Request: </i>Сервер не может обработать запрос из-за неверного синтаксиса.</li>
                  <li><i>401 Unauthorized: </i>Для доступа к запрашиваемому ресурсу требуется аутентификация.</li>
                  <li><i>403 Forbidden: </i>Сервер понял запрос, но отказывается его авторизовать.</li>
                  <li><i>404 Not Found: </i>Запрашиваемый ресурс не найден на сервере.</li>
                  <li><i>405 Method Not Allowed: </i>Метод, указанный в запросе, не поддерживается для данного ресурса.
                  </li>
                </ul>
                <p><b>5xx: Ошибки сервера</b></p>
                <ul class="top">
                  <li><i>500 Internal Server Error: </i>Общая ошибка сервера, когда сервер сталкивается с
                    непредвиденными обстоятельствами.</li>
                  <li><i>501 Not Implemented: </i>Сервер не поддерживает функциональные возможности, необходимые для
                    обработки запроса.</li>
                  <li><i>502 Bad Gateway: </i>Сервер, выступая в роли шлюза или прокси, получил неверный ответ от
                    вышестоящего сервера.</li>
                  <li><i>503 Service Unavailable: </i>Сервер временно не может обработать запрос из-за перегрузки или
                    технического обслуживания.</li>
                  <li><i>504 Gateway Timeout: </i>Шлюз или прокси-сервер не получил вовремя ответ от вышестоящего
                    сервера для завершения запроса.</li>
                </ul>
                <p>Эти статусные коды являются частью протокола HTTP и используются веб-серверами для коммуникации с
                  клиентами (например, веб-браузерами) о состоянии и результатах обработки их запросов.</p>
              </div>
            </div>

            <div class="tab-item" id="51">
              <div class="tab__box">
                <p><i>Кросс-браузерное тестирование </i>— это процесс проверки того, как веб-приложения или веб-сайты
                  отображаются и функционируют в различных веб-браузерах.
                </p>
                <p><i>Цель </i>его заключается в обеспечении того, чтобы веб-приложение или сайт предоставлял одинаково
                  высокий уровень пользовательского опыта, независимо от того, какой браузер или устройство использует
                  конечный пользователь. </p>
                <p>Это важно, поскольку разные браузеры могут интерпретировать код веб-страницы по-разному, что может
                  привести к различиям в отображении или функциональности.</p>
                <p><b>Основные аспекты:</b></p>
                <ul class="top">
                  <li><i>Совместимость с браузерами: </i>Проверка веб-сайтов и приложений на совместимость с популярными
                    веб-браузерами, такими как Google Chrome, Mozilla Firefox, Safari, Microsoft Edge и другими.</li>
                  <li><i>Совместимость с операционными системами: </i>Убедиться, что веб-приложения работают корректно
                    на различных операционных системах, включая Windows, macOS, Linux, Android и iOS.</li>
                  <li><i>Адаптивность и отзывчивость: </i>Проверка того, как веб-приложение или сайт адаптируется к
                    различным размерам экранов и разрешениям, включая настольные компьютеры, ноутбуки, планшеты и
                    смартфоны.</li>
                  <li><i>Функциональность: </i>Убедиться, что все функции веб-сайта работают одинаково хорошо во всех
                    браузерах и на всех платформах.</li>
                  <li><i>Визуальное отображение: </i>Проверка того, что элементы дизайна (как статические, так и
                    динамические) отображаются корректно в разных браузерах.</li>
                </ul>
                <p><b>Методы:</b></p>
                <ul>
                  <li><i>1. Ручное тестирование: </i>Непосредственное тестирование веб-сайта или приложения в различных
                    браузерах и на разных устройствах вручную. <br>Это может быть трудоемко, но позволяет точно оценить
                    пользовательский опыт.</li>
                  <li><i>2. Автоматизированное тестирование: </i>Использование специализированных инструментов и
                    фреймворков для автоматизации процесса тестирования. <br>Это повышает эффективность и покрытие
                    тестирования, позволяя быстро проверять веб-приложение на большом количестве комбинаций браузеров и
                    операционных систем.</li>
                  <li><i>3. Использование облачных сервисов: </i>Платформы, такие как BrowserStack и Sauce Labs,
                    предоставляют доступ к множеству браузеров и операционных систем в облаке, позволяя тестировать
                    веб-приложения без необходимости иметь все эти браузеры и устройства физически.</li>
                </ul>
                <p>Кросс-браузерное тестирование критически важно для обеспечения качества веб-разработки, поскольку
                  позволяет гарантировать, что веб-сайт или приложение будет работать надежно и предсказуемо для широкой
                  аудитории пользователей, независимо от их предпочтений в веб-браузерах или типах устройств. <br>Это
                  способствует улучшению пользовательского опыта, увеличению удовлетворенности пользователей и, как
                  следствие, повышению успеха веб-проекта.</p>
              </div>
            </div>

            <div class="tab-item" id="52">
              <div class="tab__box">
                <p>Запрос на сервер в контексте веб-разработки обычно осуществляется с использованием протокола HTTP или
                  HTTPS и состоит из нескольких ключевых компонентов, которые сообщают серверу, что именно клиент
                  (например, веб-браузер или мобильное приложение) хочет сделать, и какие данные он отправляет.</p>
                <p>Вот основные элементы запроса на сервер:</p>
                <ul>
                  <li><i>1. Метод запроса</i><br>Определяет тип операции, которую нужно выполнить. <br>Наиболее
                    распространенные методы HTTP включают:
                    <ul class="top">
                      <li><i>`GET` </i>для запроса данных от сервера.</li>
                      <li><i>`POST` </i> для отправки данных на сервер для создания или обновления ресурса.</li>
                      <li><i>`PUT` </i>для полного обновления существующего ресурса.</li>
                      <li><i>`DELETE` </i>для удаления ресурса.</li>
                      <li><i>`PATCH` </i>для частичного обновления ресурса.</li>
                    </ul>
                  </li>
                  <li><i>2. URL (Uniform Resource Locator)</i><br>Указывает сервер и точный адрес (путь) ресурса на
                    сервере, с которым клиент хочет взаимодействовать. <br>URL включает в себя протокол (например, http
                    или
                    https), доменное имя или IP-адрес сервера, порт (опционально) и путь к ресурсу.</li>
                  <li><i>3. Заголовки (Headers)</i><br>Содержат дополнительную информацию о запросе и клиенте,
                    отправляющем запрос. <br>Заголовки могут включать тип содержимого (Content-Type), типы принимаемого
                    содержимого (Accept), параметры аутентификации, куки (Cookies) и многое другое. <br>Заголовки
                    позволяют клиенту и серверу передавать дополнительные параметры и настройки.</li>
                  <li><i>4. Тело запроса (Body)</i><br>Необязательный компонент, присутствующий в некоторых типах
                    запросов (например, POST, PUT, PATCH), содержащий отправляемые данные. <br>В теле запроса могут
                    находиться данные формы, файлы, JSON или XML-структуры и т. д. <br>Тело запроса используется для
                    передачи информации от клиента к серверу.</li>
                  <li><i>5. Параметры запроса (Query Parameters)</i><br>Опциональные ключи и значения, которые
                    добавляются к URL запроса после знака вопроса (`?`). <br>Параметры запроса используются для передачи
                    дополнительной информации серверу, например, для фильтрации результатов или указания определённой
                    страницы пагинации. <br>Например: <i>`?page=1&limit=10`</i> .</li>
                  <li><i>6. Куки (Cookies)</i><br>Хотя они обычно передаются в заголовках запроса, они играют важную
                    роль в управлении сессиями и аутентификации пользователя, позволяя серверу идентифицировать
                    возвращающихся пользователей.</li>
                </ul>
                <p>Эти компоненты вместе формируют HTTP-запрос, который отправляется серверу. <br>Сервер затем
                  обрабатывает
                  запрос согласно своей логике и отправляет ответ обратно клиенту, обычно также в форме, состоящей из
                  статуса ответа, заголовков и тела ответа.</p>
              </div>
            </div>

            <div class="tab-item" id="53">
              <div class="tab__box">
                <p>Ответ сервера в контексте веб-коммуникации, осуществляемой через протокол HTTP или HTTPS, состоит из
                  нескольких ключевых компонентов. <br>Эти компоненты предоставляют клиенту (например, веб-браузеру)
                  информацию о результате обработки его запроса. </p>
                <p>Вот основные элементы ответа сервера:</p>
                <ul>
                  <li><i>1. Статусная строка (Status Line)</i><br>Содержит версию протокола HTTP, используемую сервером,
                    числовой статусный код ответа, указывающий на результат обработки запроса, и текстовое описание
                    статусного кода. Например, "HTTP/1.1 200 OK" или "HTTP/1.1 404 Not Found".</li>
                  <li><i>2. Заголовки ответа (Response Headers)</i><br>Предоставляют дополнительную информацию о сервере
                    и о том, как должен быть обработан ответ. <br>Заголовки могут включать тип содержимого
                    (`Content-Type`), дату и время ответа (`Date`), параметры кэширования (`Cache-Control`) и другие
                    данные, связанные с безопасностью, сжатием, куки и т.д.</li>
                  <li><i>3. Пустая строка</i><br>Отделяет заголовки ответа от тела ответа. <br>Эта пустая строка
                    является обязательной и указывает на окончание заголовков.</li>
                  <li><i>4. Тело ответа (Response Body)</i><br>Содержит данные, запрошенные клиентом. В зависимости от
                    типа запроса и статусного кода, тело ответа может содержать запрошенную веб-страницу, данные в
                    форматах JSON или XML (для REST API), сообщение об ошибке или может быть пустым (например, при
                    ответе со статусным кодом 204 No Content).
                    <ul class="top">Примеры:
                      <li><i>Веб-страницы: </i>При запросе веб-страницы тело ответа обычно содержит HTML-код страницы.
                      </li>
                      <li><i>API-запросы: </i>При запросах к API тело ответа часто содержит данные в формате JSON или
                        XML, которые могут представлять результаты запроса, данные сущности или сообщение об ошибке.
                      </li>
                      <li><i>Загрузка файлов: </i>При загрузке файлов с сервера тело ответа содержит бинарные данные
                        файла.</li>
                    </ul>
                  </li>
                </ul>
                <p>Каждый из этих компонентов играет важную роль в обеспечении эффективного взаимодействия между
                  клиентом и сервером. <br>Статусный код помогает клиенту определить результат обработки запроса
                  (успешно, ошибка, перенаправление и т.д.), заголовки предоставляют метаинформацию о ответе и его
                  обработке, а тело ответа содержит собственно запрошенные данные.</p>
              </div>
            </div>

            <div class="tab-item" id="54">
              <div class="tab__box">
                <p>Основными и чаще всего используемыми методами являются GET, POST, PUT, DELETE, которые эквивалентны
                  базовым функциям при работе с БД или любыми хранимыми вычислительными сущностями - CRUD (create, read,
                  update, delete).</p>
                <p>__________________</p>
                <p>HTTP (HyperText Transfer Protocol) определяет набор методов запросов, которые указывают действие,
                  требуемое для ресурса. <br>Каждый из этих методов исполняет определённую операцию и предназначен для
                  выполнения конкретных задач в контексте веб-коммуникаций. </p>
                <p>Вот наиболее часто используемые методы:</p>
                <ul>
                  <li><i>1. GET</i><br>Используется для запроса данных от указанного ресурса. <br>Данный метод
                    запрашивает представление ресурса и должен только извлекать данные, не влияя на них.</li>
                  <li><i>2. POST</i><br>Применяется для отправки данных на сервер для создания нового ресурса. <br>Часто
                    используется при заполнении форм на веб-сайтах.</li>
                  <li><i>3. PUT</i><br>Используется для обновления существующего ресурса или создания нового по
                    указанному URI. <br>В отличие от POST, он является идемпотентным, что означает, что повторение
                    одного и того же запроса PUT несколько раз не приведёт к разным результатам.</li>
                  <li><i>4. DELETE</i><br>Предназначен для удаления указанного ресурса.</li>
                  <li><i>5. HEAD</i><br>Аналогичен методу GET, но сервер в ответе возвращает только заголовки и статус
                    код, без тела сообщения. <br>Это полезно для извлечения метаданных.</li>
                  <li><i>6. OPTIONS</i><br>Используется для описания параметров связи с ресурсом. <br>С помощью OPTIONS
                    клиент может узнать, какие методы поддерживаются для ресурса.</li>
                  <li><i>7. PATCH</i><br>Применяется для частичного изменения ресурса. <br>В отличие от PUT, который
                    обновляет полностью весь ресурс, PATCH применяется для обновления только некоторых его частей.</li>
                  <li><i>8. TRACE</i><br>Выполняет тестовый цикл обратной передачи сообщения между клиентом и сервером.
                    <br>Этот метод полезен для диагностических целей, так как позволяет клиенту увидеть, что приходит
                    обратно от сервера.
                  </li>
                  <li><i>9. CONNECT</i><br>Используется для преобразования соединения запроса в прозрачный TCP/IP
                    туннель, обычно для установления зашифрованного SSL соединения через нешифрованный HTTP прокси.</li>
                </ul>
                <p>Каждый из этих методов поддерживает различные аспекты взаимодействия с ресурсами и предназначен для
                  определённых задач в рамках HTTP-протокола, обеспечивая гибкость и мощные возможности для
                  разработчиков веб-приложений.</p>
              </div>
            </div>

            <div class="tab-item" id="55">
              <div class="tab__box">
                <p>Ошибка 405 HTTP, или "405 Method Not Allowed", указывает на то, что метод HTTP, использованный в
                  запросе к серверу, не поддерживается для указанного ресурса. <br>Каждый ресурс на веб-сервере может
                  поддерживать разные методы HTTP (например, GET, POST, DELETE, PUT), и данная ошибка генерируется,
                  когда для запрошенного ресурса используется метод, который не разрешён или не поддерживается сервером
                  для этого конкретного URL.</p>
                <p>Например, если веб-форма только принимает данные через метод POST, а клиент отправляет данные с
                  использованием метода GET, сервер может вернуть эту ошибку. <br>Точно так же, если попытаться
                  использовать метод DELETE на ресурсе, который не поддерживает удаление содержимого, сервер также может
                  ответить с этим статусным кодом.
                </p>
                <p>Как действовать при получении ошибки:</p>
                <ul>
                  <li><i>Проверить метод HTTP: </i>Убедитесь, что используемый метод HTTP подходит для выполняемой
                    операции. <br>Например, для получения данных должен использоваться метод GET, для отправки данных —
                    POST, для обновления существующих данных — PUT, и так далее.</li>
                  <li><i>Документация API: </i>Если ошибка возникает при взаимодействии с API, полезно проверить
                    документацию API на предмет поддерживаемых методов HTTP для запрашиваемого ресурса.</li>
                  <li><i>Обращение к разработчикам: </i>Если проблема не решается и вы уверены, что используете
                    правильный метод, возможно, стоит обратиться к разработчикам веб-сервиса или веб-сайта за
                    разъяснениями.</li>
                </ul>
                <p>В ответе на запрос, который приводит к ошибке 405, сервер часто включает заголовок "Allow",
                  указывающий, какие методы HTTP поддерживаются для данного ресурса. <br>Это может помочь в определении
                  правильного метода для использования.</p>
              </div>
            </div>

            <div class="tab-item" id="56">
              <div class="tab__box">
                <p>Ошибка 500, или HTTP Status 500 Internal Server Error, является общим кодом состояния HTTP, который
                  указывает на внутреннюю ошибку сервера. <br>Это означает, что сервер столкнулся с непредвиденной
                  ситуацией, которая не позволила ему выполнить запрос клиента.
                </p>
                <p>Важно отметить, что ошибка 500 является общей и не предоставляет конкретных деталей о причине сбоя.
                </p>
                <p>Это может быть вызвано множеством различных проблем на стороне сервера, таких как:</p>
                <ul class="top">
                  <li>Проблемы с конфигурацией сервера.</li>
                  <li>Ошибки в скриптах или программном обеспечении сервера.</li>
                  <li>Неисправности в базе данных.</li>
                  <li>Проблемы с несовместимостью между серверными компонентами.</li>
                  <li>Исчерпание ресурсов сервера, например, из-за высокой нагрузки.</li>
                </ul>
                <p>Когда возникает данная ошибка, важно для веб-разработчиков или администраторов сервера проверить
                  журналы ошибок сервера для выяснения конкретной причины. <br>Решение проблемы может включать
                  исправление кода, настройку параметров сервера, увеличение ресурсов сервера или обновление
                  программного обеспечения.</p>
                <p>Для пользователей, сталкивающихся с ошибкой 500 при попытке доступа к веб-сайту, рекомендуется
                  попробовать перезагрузить страницу через некоторое время или связаться с владельцем веб-сайта, если
                  проблема сохраняется.</p>
              </div>
            </div>

            <div class="tab-item" id="57">
              <div class="tab__box">
                <p>Ожидаемые результаты для тестирования ПО определяют, как должна вести себя система или приложение при
                  заданных условиях. <br>Они являются ключевым элементом тест-кейсов, позволяя оценить, был ли тест
                  пройден успешно. </p>
                <p>Вот основные источники, из которых можно взять ожидаемые результаты:</p>
                <ul>
                  <li><i>1. Техническое задание и спецификации требований</i><br>Ожидаемые результаты часто основываются
                    на формальных требованиях к продукту, описанных в документации, такой как функциональные и
                    нефункциональные требования. <br>Эти документы содержат детальное описание того, как должны работать
                    определённые функции и модули системы.</li>
                  <li><i>2. Дизайн и прототипы интерфейса</i><br>Макеты интерфейса пользователя и прототипы могут
                    служить источником ожидаемых результатов, особенно для тестирования соответствия дизайну и
                    пользовательскому опыту.</li>
                  <li><i>3. Стандарты и нормативы</i><br>В некоторых случаях ожидаемые результаты могут быть определены
                    стандартами качества или отраслевыми нормативами, которым должно соответствовать ПО.</li>
                  <li><i>4. Пользовательские сценарии и истории</i><br>Ожидаемые результаты можно извлечь из
                    пользовательских сценариев и историй, которые описывают, как система должна вести себя из точки
                    зрения конечного пользователя при выполнении конкретных задач.</li>
                  <li><i>5. Предыдущие версии продукта</i><br>Для регрессионного тестирования ожидаемые результаты могут
                    основываться на поведении и функциях предыдущих версий продукта, чтобы убедиться, что новые
                    изменения не нарушили существующую функциональность.</li>
                  <li><i>6. Знание домена и экспертные мнения</i><br>Опыт и знания экспертов в предметной области могут
                    помочь определить ожидаемые результаты, особенно в сложных или специализированных приложениях, где
                    требования могут не быть полностью документированы.</li>
                  <li><i>7. Законодательство и регулирование</i><br>В некоторых сферах, таких как банковское дело,
                    здравоохранение и страхование, ожидаемые результаты могут также определяться соответствующими
                    законодательными и регуляторными требованиями.</li>
                  <li><i>8. Обратная связь от пользователей</i><br>Отзывы и предложения от реальных пользователей могут
                    выявить ожидания относительно поведения и функциональности продукта, которые следует учитывать при
                    тестировании.</li>
                </ul>
                <p>Определение ожидаемых результатов требует тщательного анализа и понимания продукта и его контекста.
                  Чётко определённые ожидаемые результаты упрощают процесс тестирования, позволяя объективно оценить
                  соответствие ПО его требованиям и целям.</p>
              </div>
            </div>

            <div class="tab-item" id="60">
              <div class="tab__box">
                <p><i>API тестирование </i>— это процесс проверки Application Programming Interfaces (APIs) на
                  корректность работы, безопасность, производительность и надежность. <br>Он представляет собой набор
                  определений и протоколов для создания и интеграции программного обеспечения, позволяя различным
                  приложениям взаимодействовать друг с другом без необходимости знать детали их реализации.</p>
                <p><b>Основные аспекты:</b></p>
                <ul class="top">
                  <li><i>Функциональное тестирование: </i>Проверка того, что он работает в соответствии с ожиданиями,
                    включая правильность выполнения запросов и возврата ответов, а также обработку ошибок.</li>
                  <li><i>Тестирование безопасности: </i>Проверка на наличие уязвимостей, таких как SQL-инъекции,
                    небезопасное хранение данных и проблемы с аутентификацией и авторизацией.</li>
                  <li><i>Тестирование производительности: </i>Оценка того, насколько он хорошо справляется с большими
                    объемами данных и высокой нагрузкой, а также проверка времени отклика.</li>
                  <li><i>Тестирование совместимости: </i>Убедиться, что он корректно работает в различных средах, на
                    разных платформах и с различными версиями программного обеспечения.</li>
                  <li><i>Тестирование надежности: </i>Проверка его способности стабильно работать и восстанавливаться
                    после сбоев.</li>
                </ul>
                <p><b>Преимущества:</b></p>
                <ul class="top">
                  <li><i>Раннее обнаружение ошибок: </i>Данное тестирование позволяет идентифицировать проблемы на
                    раннем этапе разработки, что упрощает и удешевляет их исправление.</li>
                  <li><i>Автоматизация: </i>Большинство таких тестов можно автоматизировать, что ускоряет процессы
                    тестирования и повышает их эффективность.</li>
                  <li><i>Языконезависимость: </i>Может проводиться независимо от языка программирования приложения, так
                    как API предоставляет стандартизированный интерфейс доступа.</li>
                  <li><i>Точное тестирование: </i>Позволяет точно проверить бизнес-логику приложения, минуя
                    пользовательский интерфейс.</li>
                </ul>
                <p><b>Существует множество инструментов для автоматизации тестирования API, включая:</b></p>
                <ul class="top">
                  <li><i>Postman: </i>Для его разработки и тестирования, поддерживающий множество функций для отправки
                    запросов и анализа ответов.</li>
                  <li><i>SoapUI: </i>Для тестирования веб-сервисов, поддерживающий как REST, так и SOAP API.</li>
                  <li><i>Swagger или OpenAPI: </i>Для его документирования, которые также могут быть использованы для
                    создания живых интерфейсов для тестирования.</li>
                  <li><i>Apache JMeter: </i>Для тестирования производительности, который также может быть использован
                    для функционального тестирования API.</li>
                </ul>
                <p>API тестирование является ключевой частью обеспечения качества программного обеспечения, позволяя
                  гарантировать, что интерфейсы, через которые взаимодействуют различные части системы или разные
                  системы, работают корректно и надежно.</p>
              </div>
            </div>

            <div class="tab-item" id="61">
              <div class="tab__box">
                <p>API (Application Programming Interface) для веб-клиента и мобильного приложения могут отличаться по
                  ряду аспектов, хотя в основе своей выполняют похожие функции — обеспечивают интерфейс для
                  взаимодействия между клиентом и сервером. <br>Различия между API для веба и мобильных устройств часто
                  связаны с особенностями платформ, требованиями к производительности и безопасности, а также с
                  конкретными задачами, которые эти API должны решать. </p>
                <p>Вот некоторые из основных отличий:</p>
                <ul>
                  <li><i>1. Оптимизация производительности</i>
                    <ul class="top">
                      <li><i>Мобильные API </i>часто требуют более тщательной оптимизации производительности из-за
                        ограниченных вычислительных ресурсов устройств и нестабильности мобильных сетей. <br>Это может
                        включать минимизацию объема передаваемых данных, использование кэширования и адаптацию качества
                        контента (например, изображений) к условиям сети.</li>
                      <li><i>Веб-клиенты </i>могут рассчитывать на более стабильное и быстрое соединение, поэтому
                        оптимизация может быть менее критичной, хотя всё ещё важной для улучшения пользовательского
                        опыта.</li>
                    </ul>
                  </li>
                  <li><i>2. Аутентификация и безопасность</i>
                    <ul class="top">
                      <li><i>Мобильные API </i>могут использовать специфические для платформы методы аутентификации,
                        такие как OAuth 2.0, JWT (JSON Web Tokens) или даже биометрическую аутентификацию, чтобы
                        обеспечить безопасный доступ к данным.</li>
                      <li><i>Веб-API </i>также используют стандартные протоколы безопасности, но могут чаще полагаться
                        на сессии и куки для управления состоянием аутентификации.</li>
                    </ul>
                  </li>
                  <li><i>3. Адаптивность и отзывчивость</i>
                    <ul class="top">
                      <li><i>API для мобильных приложений </i>должны быть спроектированы с учетом разнообразия
                        устройств, размеров экранов и платформ (iOS, Android), что может потребовать создания
                        специализированных эндпоинтов или версий API.</li>
                      <li><i>Веб-API </i>обслуживают клиентов, работающих в более стандартизированной среде
                        веб-браузеров, где основное внимание уделяется совместимости с различными браузерами и поддержке
                        современных веб-стандартов.</li>
                    </ul>
                  </li>
                  <li><i>4. Интерактивность и функциональность</i>
                    <ul class="top">
                      <li><i>Мобильные приложения </i>зачастую требуют более глубокой интеграции с нативными функциями
                        устройства, такими как доступ к камере, GPS, акселерометру, что требует от API поддержки
                        соответствующих функций.</li>
                      <li><i>Веб-приложения </i>могут быть ограничены в доступе к некоторым нативным функциям
                        устройства, но в то же время могут использовать преимущества более мощных вычислительных
                        ресурсов и большего экранного пространства.</li>
                    </ul>
                  </li>
                  <li><i>5. Сценарии использования</i>
                    <ul class="top">
                      <li>API для <i>мобильных приложений </i>асто разрабатываются с учетом специфики мобильного
                        использования, включая оффлайн-режим работы, быструю реакцию на действия пользователя и
                        минимизацию задержек.</li>
                      <li>API для <i>веб-приложений </i>могут быть нацелены на обеспечение более богатого
                        пользовательского интерфейса и сложных веб-взаимодействий, полагаясь на постоянное соединение с
                        сетью.</li>
                    </ul>
                  </li>
                </ul>
                <p>Хотя многие основные принципы разработки API одинаковы для веба и мобильных устройств, различия в
                  требованиях к производительности, безопасности, интерактивности и функциональности зачастую требуют
                  адаптации API под конкретную платформу.</p>
              </div>
            </div>

            <div class="tab-item" id="62">
              <div class="tab__box">
                <p><i>Клиент-серверная архитектура</i> — это распределённая модель взаимодействия, в которой задачи или
                  рабочие нагрузки распределены между поставщиками услуг, называемыми серверами, и запросчиками услуг,
                  называемыми клиентами. <br>Обычно клиенты и серверы взаимодействуют через сеть на основе
                  стандартизированных протоколов коммуникации. <br>Эта архитектура широко используется в разработке
                  программного обеспечения для создания приложений и сервисов.</p>
                <p>Основные характеристики:</p>
                <ul class="top">
                  <li><i>Разделение функций: </i>Отвечает за представление данных пользователю и взаимодействие с
                    пользователем, в то время как сервер занимается обработкой данных, управлением ресурсами и
                    выполнением задач.</li>
                  <li><i>Централизованное управление: </i>Данные и управляющая логика часто централизованы на сервере,
                    что облегчает обновление, обслуживание и управление безопасностью.</li>
                  <li><i>Масштабируемость: </i>Архитектура позволяет легко добавлять, обновлять и масштабировать
                    серверные ресурсы в ответ на изменяющиеся требования без необходимости изменения клиентской части.
                  </li>
                  <li><i>Гибкость: </i>Могут взаимодействовать с различными серверами, а сервера могут обслуживать
                    различных клиентов, что обеспечивает высокую степень гибкости и повторное использование компонентов.
                  </li>
                </ul>
                <p>Компоненты:</p>
                <ul class="top">
                  <li><i>Клиент (Client): </i>Приложение или устройство, используемое пользователем для доступа к
                    сервисам и ресурсам сервера. <br>Клиенты инициируют запросы к серверам.</li>
                  <li><i>Сервер (Server)^ </i>Мощная система или программное обеспечение, обрабатывающее запросы
                    клиентов, выполняет обработку данных, управляет ресурсами (например, базами данных) и предоставляет
                    различные сервисы.</li>
                  <li><i>Сеть (Network): </i>Среда передачи данных, которая соединяет клиентов и серверы, обычно через
                    Интернет или локальную сеть (LAN).
                  </li>
                </ul>
                <p>Типы клиент-серверных архитектур:</p>
                <ul class="top">
                  <li><i>Одноуровневая (1-Tier): </i>Клиент и сервер находятся на одной машине, и нет сетевого
                    взаимодействия.</li>
                  <li><i>Двухуровневая (2-Tier): </i>Прямое взаимодействие между клиентом и сервером, например,
                    клиентское приложение взаимодействует напрямую с базой данных на сервере.</li>
                  <li><i>Трёхуровневая (3-Tier): </i>Включает промежуточный уровень, например, приложение сервера,
                    которое действует как посредник между клиентом и сервером базы данных, облегчая процесс обработки
                    запросов.
                  </li>
                  <li><i>Многоуровневая (N-Tier): </i>Более сложная структура с несколькими уровнями, которые могут
                    включать балансировщики нагрузки, сервера приложений, сервера баз данных, сервера кэширования и т.д.
                  </li>
                </ul>
                <p>Клиент-серверная архитектура остаётся основным выбором для разработки современных приложений
                  благодаря своей гибкости, масштабируемости и эффективности в управлении ресурсами и обработке данных.
                </p>
              </div>
            </div>

            <div class="tab-item" id="63">
              <div class="tab__box">
                <p>Если сервер "сломан" или сталкивается с внутренней ошибкой, которая мешает ему корректно обработать
                  запрос, обычно возвращается статус код <i>500 Internal Server Error</i>. <br>Этот код состояния HTTP
                  указывает на то, что сервер столкнулся с непредвиденной ситуацией, которая не позволяет ему выполнить
                  запрос из-за какой-либо внутренней ошибки или неполадки.</p>
                <p>Код 500 является общим сигналом о том, что на сервере произошла ошибка, не позволяющая ему успешно
                  обработать запрос, и точная причина ошибки не специфицируется в ответе. <br>Это может быть связано с
                  проблемами в программном обеспечении сервера, ошибками в коде приложения, неполадками в системе
                  управления базами данных или другими внутренними сбоями.</p>
                <p>Важно отметить, что для диагностики и устранения причин, приведших к ошибке 500, необходимо
                  обратиться к журналам ошибок сервера или системы управления контентом, которые могут предоставить
                  более детальную информацию о сбое.</p>
              </div>
            </div>

            <div class="tab-item" id="64">
              <div class="tab__box">
                <p><i>Тестирование API (Application Programming Interface)</i> — это процесс проверки интерфейсов ПО,
                  который включает в себя серию вызовов API с целью проверки их функциональности, производительности,
                  безопасности и надёжности. <br>При тестировании API особое внимание уделяется запросам и ответам, а
                  также обработке и валидации данных.</p>
                <p>Вот основные виды тестирования:</p>
                <ul>
                  <li><i>1. Функциональное тестирование</i><br>Целью функционального тестирования API является проверка
                    того, что API работает в соответствии с ожиданиями и требованиями к функциональности. <br>Это
                    включает в себя тестирование отдельных методов и функций API для убедительности в том, что они
                    возвращают правильные ответы при получении ожидаемых входных данных.</li>
                  <li><i>2. Тестирование производительности</i><br>Оценивает, как API справляется с большим объёмом
                    запросов в единицу времени, а также время отклика на эти запросы. <br>Это включает в себя
                    нагрузочное тестирование, стресс-тестирование и тестирование на пропускную способность.</li>
                  <li><i>3. Тестирование безопасности</i><br>Проверяет устойчивость API к различным угрозам
                    безопасности, включая SQL-инъекции, переполнение буфера, недостатки аутентификации и авторизации, а
                    также уязвимости, связанные с передачей данных.</li>
                  <li><i>4. Тестирование совместимости</i><br>Убеждается, что API корректно работает в различных средах
                    и конфигурациях, включая различные операционные системы, платформы и сетевые условия.</li>
                  <li><i>5. Тестирование надёжности</i><br>Проверяет способность API восстанавливаться после сбоев и
                    продолжать работать стабильно в условиях различных сценариев использования.</li>
                  <li><i>6. Тестирование документации API</i><br>Оценивает полноту, точность и понятность документации
                    API, поскольку она является ключевым ресурсом для разработчиков, интегрирующих и использующих API в
                    своих приложениях.</li>
                  <li><i>7. Тестирование контрактов API</i><br>Используется для проверки, что API соответствует своему
                    специфицированному интерфейсу или "контракту", обычно описанному с помощью спецификаций, таких как
                    OpenAPI (Swagger). <br>Это помогает убедиться, что изменения в API не нарушают существующую
                    интеграцию.</li>
                </ul>
                <p><b>Инструменты:</b><br>Существует множество инструментов для тестирования API, включая Postman,
                  SoapUI, Insomnia и другие, которые облегчают процесс тестирования за счет предоставления
                  пользовательского интерфейса для отправки запросов к API, анализа ответов и автоматизации тестов.</p>
                <p>Тестирование API является критически важным элементом процесса разработки ПО, поскольку API часто
                  служат мостом между различными частями приложения или между разными приложениями и сервисами.</p>
              </div>
            </div>

            <div class="tab-item" id="65">
              <div class="tab__box">
                <p>Тестирование веб-приложений включает в себя различные виды и методы, направленные на обеспечение их
                  надежности, безопасности, удобства использования и соответствия требованиям. </p>
                <p>Вот некоторые из ключевых видов тестирования, применимых к веб-приложениям:</p>
                <ul>
                  <li><i>1. Функциональное тестирование</i><br>Проверка соответствия функциональности веб-приложения
                    заданным требованиям и спецификациям. <br>Это включает в себя тестирование всех функций через
                    пользовательский интерфейс, API и другие взаимодействия с приложением.</li>
                  <li><i>2. Тестирование пользовательского интерфейса (UI)</i><br>Фокусируется на проверке элементов
                    интерфейса пользователя, включая расположение кнопок, поля ввода, навигацию, цвета, шрифты и
                    отзывчивость элементов управления.</li>
                  <li><i>3. Тестирование совместимости (Кросс-браузерное и кросс-платформенное)</i><br>Проверка работы
                    веб-приложения в различных веб-браузерах (например, Chrome, Firefox, Safari) и на различных
                    устройствах и операционных системах (Windows, macOS, Android, iOS) для обеспечения универсальности
                    доступа.</li>
                  <li><i>4. Тестирование производительности</i><br>Оценка скорости, стабильности и масштабируемости
                    веб-приложения под нагрузкой. <br>Это включает в себя нагрузочное тестирование, стресс-тестирование,
                    тестирование на пропускную способность и объемное тестирование.</li>
                  <li><i>5. Тестирование безопасности</i><br>Идентификация уязвимостей веб-приложения, которые могут
                    быть использованы злоумышленниками. <br>Включает в себя проверку на SQL-инъекции, кросс-сайтовый
                    скриптинг (XSS), разглашение конфиденциальной информации, неправильную обработку сессий и токенов
                    доступа.</li>
                  <li><i>6. Тестирование доступности</i><br>Обеспечение того, чтобы веб-приложение было доступно и
                    удобно для использования широким кругом пользователей, включая людей с ограниченными возможностями,
                    с помощью специальных технологических средств.</li>
                  <li><i>7. Тестирование удобства использования (Usability Testing)</i><br>Оценка того, насколько легко
                    конечные пользователи могут научиться использовать приложение, находить необходимую информацию и
                    выполнять задачи.</li>
                  <li><i>8. Регрессионное тестирование</i><br>Проверка того, что новые изменения, добавленные в
                    приложение, не нарушили существующую функциональность. <br>Это критически важно при каждом
                    обновлении или добавлении новых функций.</li>
                  <li><i>9. Эксплораторское тестирование</i><br>Неформализованный подход к тестированию, при котором
                    тестировщики исследуют приложение без строго заданных сценариев, используя свой опыт и интуицию для
                    поиска дефектов.</li>
                  <li><i>10. Тестирование локализации</i><br>Проверка правильности работы приложения в различных
                    локализациях, включая перевод текстов и форматирование данных (даты, валюты и т.д.), адаптированные
                    для конкретных регионов или культур.</li>
                </ul>
                <p>Комбинирование этих видов тестирования позволяет создать всесторонний план тестирования, который
                  обеспечит высокое качество веб-приложения и хороший пользовательский опыт.</p>
              </div>
            </div>

            <div class="tab-item" id="66">
              <div class="tab__box">
                <p><i>HTTP (HyperText Transfer Protocol — протокол передачи гипертекста)</i> — это основной протокол для
                  передачи данных, особенно веб-страниц, изображений, видео и других ресурсов в World Wide Web.
                  <br>Разработанный в начале 1990-х годов Тимом Бернерсом-Ли, HTTP определяет способ взаимодействия
                  между веб-клиентами (обычно веб-браузерами) и веб-серверами. <br>Он является частью более обширного
                  протокола TCP/IP, который лежит в основе всей сетевой коммуникации в Интернете.
                </p>
                <p><b>Как он работает</b></p>
                <ul>
                  <li><i>1. Запрос от клиента: </i> Когда пользователь вводит URL веб-сайта в браузере или кликает на
                    ссылку, браузер отправляет запрос HTTP на сервер, где расположен запрашиваемый ресурс.</li>
                  <li><i>2. Обработка запроса сервером: </i>Веб-сервер принимает запрос, обрабатывает его и возвращает
                    ответ, который может включать запрошенный контент (например, HTML-страницу) или сообщение об ошибке,
                    если ресурс не найден или доступ к нему запрещён.</li>
                  <li><i>3. Ответ сервера: </i>Ответ содержит статус выполнения запроса (код состояния) и, при успешном
                    запросе, запрошенные данные.</li>
                </ul>
                <p><b>Особенности:</b></p>
                <ul class="top">
                  <li><i>Безсостояний: </i>Является протоколом без сохранения состояния (stateless), что означает, что
                    каждый запрос обрабатывается независимо, без сохранения информации о предыдущих взаимодействиях.
                    <br>Это упрощает архитектуру, но для сохранения состояния между запросами используются куки и
                    сессии.
                  </li>
                  <li><i>Простота и расширяемость: </i>Предлагает простую структуру запросов и ответов, которая легко
                    расширяема через заголовки для передачи дополнительной информации.</li>
                  <li><i>Методы запросов: </i>Определяет различные методы запросов, такие как GET для получения данных,
                    POST для отправки данных на сервер, DELETE для удаления ресурсов и другие, позволяя реализовывать
                    различные операции над ресурсами.</li>
                  <li><i>Безопасность: </i>Поскольку он по умолчанию не шифрует данные, передаваемые между клиентом и
                    сервером, для обеспечения безопасности часто используется HTTPS (HTTP Secure), который добавляет
                    шифрование с помощью SSL/TLS.</li>
                </ul>
                <p>HTTP продолжает развиваться, и его последняя версия, HTTP/2 (опубликована в 2015 году), предлагает
                  улучшения в эффективности передачи данных и производительности по сравнению с предыдущими версиями.
                </p>
              </div>
            </div>

            <div class="tab-item" id="67">
              <div class="tab__box">
                <p>Протоколы HTTP (HyperText Transfer Protocol) и HTTPS (HyperText Transfer Protocol Secure) являются
                  основными протоколами для передачи данных в интернете, особенно для веб-сайтов.
                </p>
                <p>Основная разница между HTTP и HTTPS заключается в уровне безопасности при передаче данных между
                  клиентом (обычно веб-браузером) и сервером.</p>
                <p><b>HTTP</b></p>
                <ul class="top">
                  <li><i>Нешифрованное соединение: </i>Передает данные в открытом виде, что делает их уязвимыми для
                    перехвата или модификации третьими лицами. </li>
                  <li><i>Стандартный порт: </i>По умолчанию использует порт 80.</li>
                  <li><i>Быстродействие: </i>Теоретически может работать немного быстрее HTTPS из-за отсутствия процесса
                    шифрования, хотя на практике разница часто незначительна.</li>
                  <li><i>Использование: </i>Ранее широко использовался для всех видов веб-трафика, но сейчас его
                    применение сокращается в пользу более безопасного HTTPS.</li>
                </ul>
                <p><b>HTTPS</b></p>
                <ul class="top">
                  <li><i>Шифрованное соединение: </i>Использует протокол SSL/TLS для шифрования данных перед их
                    передачей, что обеспечивает конфиденциальность и защиту от "человека посередине" (man-in-the-middle)
                    атак.</li>
                  <li><i>Стандартный порт: </i>По умолчанию использует порт 443.</li>
                  <li><i>Безопасность: </i>Помимо шифрования, он также предоставляет аутентификацию сервера, гарантируя,
                    что данные отправляются именно тому серверу, для которого они предназначены, и подтверждая, что
                    сервер является тем, за кого себя выдает.</li>
                  <li><i>Использование: </i>Стал стандартом для большинства веб-сайтов, особенно тех, которые
                    обрабатывают конфиденциальную информацию, такую как данные кредитных карт, личная информация и
                    данные для входа.</li>
                </ul>
                <p>Основное отличие между HTTP и HTTPS заключается в том, что HTTPS обеспечивает зашифрованное и
                  безопасное соединение, предотвращая возможность чтения или изменения передаваемых данных третьими
                  лицами.
                </p>
                <p>Это делает HTTPS предпочтительным выбором для обеспечения безопасности и конфиденциальности в
                  Интернете.</p>
                <p>В последние годы многие веб-сайты и онлайн-сервисы перешли на использование HTTPS по умолчанию, что
                  подчеркивает важность безопасности в современном цифровом мире.</p>
              </div>
            </div>


          </div>
        </div>

      </div>

    </div>
  </header>






  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="js/slick.min.js"></script>
  <script src="js/jquery.magnific-popup.min.js"></script>
  <script src="js/jquery.fancybox.min.js"></script>
  <script src="js/main.js"></script>
</body>

</html>